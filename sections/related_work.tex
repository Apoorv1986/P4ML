\section{Related Work}
\begin{itemize}
    \item why are existing approaches insufficient?
    \item symbolic execution drawbacks --> why is symbolic execution limited? --> only focuses on what code is there but not on problems that arise from unimplemented features. 
    \item manual assertion drawbacks
    \item one by one explanation of the existing work (Vera~\cite{Stoenescu:2018:DPP:3230543.3230548}, p4v~\cite{Liu:2018:PPV:3230543.3230582}, Assertion-based verification~\cite{Freire:2018:UBP:3185467.3185499}~\cite{Neves:2018:VPP:3281411.3281421},  p4pktgen~\cite{Notzli:2018:PAT:3185467.3185497}) and explaining what the drawbacks of each of the solutions are and what kind of bugs they can not detect, which we can detect.
    \item existing approaches can already capture several kinds of bugs but are either based on symbolic execution, which is suffering from path explosion problem if the program is branchy
    \item or assume a lot of additional manual assertions inside the code to reflect expected program behaviour
    \item or require the programmer to learn logic expression language and express the whole program behaviour using that logic
    \item so these approaches are either lacking possibilities to also verify large or branchy programs but also require manual work even if the programs to be verified implement the same high level logic, e.g. layer 3 packet processing.
\end{itemize}
\ap{Also include related works like Cocoon etc. cited in Vera, P4v, ASSERT-P4, P4Packetgen to make an exhaustive table of related work to compare to make it crystal clear what they don't do and we do, like $\times$, \checkmark}